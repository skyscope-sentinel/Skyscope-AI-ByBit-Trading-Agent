"""
Autonomous Cryptocurrency Trading Agent
======================================

A sophisticated AI-powered trading system designed to turn $2 into $20,000
through aggressive scalping and momentum trading strategies.

Features:
- Real-time market analysis using OpenAI GPT-4
- High-frequency trading with sub-second execution
- Advanced risk management and position sizing
- Multi-timeframe analysis and correlation detection
- Adaptive strategies based on market conditions
- Comprehensive performance tracking and optimization

Author: Skyscope AI Trading Systems
Version: 2.0.0
"""

import asyncio
import logging
import time
import json
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from concurrent.futures import ThreadPoolExecutor
import pandas as pd
import numpy as np
from decimal import Decimal, ROUND_DOWN, ROUND_UP

from .openai_analyzer import OpenAIAnalyzer
from .bybit_connector import BybitConnector
from .advanced_risk_manager import AdvancedRiskManager
from .data_handler import DataHandler
from .logger_setup import setup_logging


@dataclass
class TradeSignal:
    """Represents a trading signal generated by the AI"""
    symbol: str
    action: str  # BUY, SELL, HOLD, CLOSE
    confidence: float
    entry_price: float
    stop_loss: float
    take_profit: float
    leverage: int
    position_size_pct: float
    strategy: str
    timeframe: str
    reasoning: str
    timestamp: datetime
    urgency: str = "NORMAL"  # LOW, NORMAL, HIGH, CRITICAL


@dataclass
class Position:
    """Represents an active trading position"""
    symbol: str
    side: str
    size: float
    entry_price: float
    current_price: float
    unrealized_pnl: float
    leverage: int
    stop_loss: float
    take_profit: float
    timestamp: datetime
    strategy: str
    trailing_stop: Optional[float] = None


@dataclass
class PerformanceMetrics:
    """Tracks trading performance metrics"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: float = 0.0
    max_drawdown: float = 0.0
    win_rate: float = 0.0
    profit_factor: float = 0.0
    sharpe_ratio: float = 0.0
    current_balance: float = 2.0
    peak_balance: float = 2.0
    daily_pnl: float = 0.0
    trades_today: int = 0


class AutonomousTrader:
    """
    The main autonomous trading agent class that orchestrates all trading activities.
    """
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize the autonomous trading agent"""
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Initialize components
        self.openai_analyzer = OpenAIAnalyzer(
            api_key=config['openai_api']['api_key'],
            model=config['openai_api']['model']
        )
        
        self.bybit_connector = BybitConnector(
            api_key=config['bybit_api']['api_key'],
            api_secret=config['bybit_api']['api_secret'],
            testnet=config['bybit_api']['testnet']
        )
        
        self.risk_manager = AdvancedRiskManager(config)
        self.data_handler = DataHandler()
        
        # Trading state
        self.active_positions: Dict[str, Position] = {}
        self.pending_orders: Dict[str, Dict] = {}
        self.performance_metrics = PerformanceMetrics()
        self.market_data_cache: Dict[str, Dict] = {}
        self.last_analysis_time: Dict[str, datetime] = {}
        
        # Control flags
        self.is_running = False
        self.emergency_stop = False
        self.maintenance_mode = False
        
        # Threading
        self.executor = ThreadPoolExecutor(max_workers=20)
        self.analysis_threads: Dict[str, threading.Thread] = {}
        
        self.logger.info("ğŸš€ Autonomous Trading Agent Initialized")
        self.logger.info(f"ğŸ’° Initial Capital: ${self.performance_metrics.current_balance}")
        self.logger.info(f"ğŸ¯ Target Capital: ${config['target_capital_usdt']}")
        
    async def start_trading(self):
        """Start the autonomous trading system"""
        self.logger.info("ğŸ”¥ STARTING AUTONOMOUS TRADING SYSTEM ğŸ”¥")
        self.is_running = True
        
        # Start monitoring threads
        monitoring_tasks = [
            self._monitor_positions(),
            self._monitor_market_data(),
            self._monitor_performance(),
            self._monitor_system_health(),
            self._execute_trading_loop()
        ]
        
        try:
            await asyncio.gather(*monitoring_tasks)
        except Exception as e:
            self.logger.error(f"âŒ Critical error in trading system: {e}")
            await self.emergency_shutdown()
    
    async def _execute_trading_loop(self):
        """Main trading execution loop"""
        while self.is_running and not self.emergency_stop:
            try:
                # Check if we've reached our target
                if self.performance_metrics.current_balance >= self.config['target_capital_usdt']:
                    self.logger.info(f"ğŸ‰ TARGET ACHIEVED! Balance: ${self.performance_metrics.current_balance}")
                    await self.celebrate_success()
                    break
                
                # Check daily limits
                if self._check_daily_limits():
                    self.logger.warning("âš ï¸ Daily limits reached, pausing trading")
                    await asyncio.sleep(3600)  # Wait 1 hour
                    continue
                
                # Analyze all symbols concurrently
                analysis_tasks = []
                for symbol in self.config['trading_symbols']:
                    if self._should_analyze_symbol(symbol):
                        task = self._analyze_and_trade_symbol(symbol)
                        analysis_tasks.append(task)
                
                if analysis_tasks:
                    await asyncio.gather(*analysis_tasks, return_exceptions=True)
                
                # Brief pause to prevent overwhelming the system
                await asyncio.sleep(self.config['ai_analysis']['analysis_interval_seconds'])
                
            except Exception as e:
                self.logger.error(f"âŒ Error in trading loop: {e}")
                await asyncio.sleep(5)
    
    async def _analyze_and_trade_symbol(self, symbol: str):
        """Analyze a symbol and execute trades if signals are found"""
        try:
            # Get market data
            market_data = await self._get_comprehensive_market_data(symbol)
            if not market_data:
                return
            
            # Generate AI analysis
            signal = await self._generate_trade_signal(symbol, market_data)
            if not signal:
                return
            
            # Execute trade if signal is strong enough
            if signal.confidence >= self.config['strategy_config']['confidence_threshold']:
                await self._execute_trade_signal(signal)
            
        except Exception as e:
            self.logger.error(f"âŒ Error analyzing {symbol}: {e}")
    
    async def _get_comprehensive_market_data(self, symbol: str) -> Optional[Dict]:
        """Get comprehensive market data for analysis"""
        try:
            # Get multiple timeframe data
            timeframes = self.config['ai_analysis']['timeframes']
            market_data = {
                'symbol': symbol,
                'timestamp': datetime.now(),
                'timeframes': {}
            }
            
            for tf in timeframes:
                # Get kline data
                klines = self.bybit_connector.get_kline(
                    category="linear",
                    symbol=symbol,
                    interval=tf,
                    limit=200
                )
                
                if klines and klines.get('retCode') == 0:
                    df = self.data_handler.process_kline_data(
                        klines['result']['list'], symbol
                    )
                    df_with_ta = self.data_handler.calculate_technical_indicators(df, symbol)
                    market_data['timeframes'][tf] = df_with_ta
            
            # Get current ticker
            ticker = self.bybit_connector.get_tickers(category="linear", symbol=symbol)
            if ticker and ticker.get('retCode') == 0:
                ticker_data = ticker['result']['list'][0]
                market_data['current_price'] = float(ticker_data['lastPrice'])
                market_data['volume_24h'] = float(ticker_data['volume24h'])
                market_data['price_change_24h'] = float(ticker_data['price24hPcnt'])
            
            # Get order book
            orderbook = self.bybit_connector.get_orderbook(category="linear", symbol=symbol)
            if orderbook and orderbook.get('retCode') == 0:
                market_data['orderbook'] = orderbook['result']
            
            # Get recent trades
            trades = self.bybit_connector.get_public_trade_history(
                category="linear", symbol=symbol, limit=100
            )
            if trades and trades.get('retCode') == 0:
                market_data['recent_trades'] = trades['result']['list']
            
            # Cache the data
            self.market_data_cache[symbol] = market_data
            return market_data
            
        except Exception as e:
            self.logger.error(f"âŒ Error getting market data for {symbol}: {e}")
            return None
    
    async def _generate_trade_signal(self, symbol: str, market_data: Dict) -> Optional[TradeSignal]:
        """Generate a trade signal using AI analysis"""
        try:
            # Construct comprehensive prompt
            prompt = self._construct_advanced_trading_prompt(symbol, market_data)
            
            # Get AI analysis
            analysis = await self.openai_analyzer.analyze_market_data(prompt)
            
            if not analysis or 'error' in analysis:
                self.logger.warning(f"âš ï¸ AI analysis failed for {symbol}")
                return None
            
            # Validate and create signal
            if self._validate_ai_response(analysis):
                signal = TradeSignal(
                    symbol=symbol,
                    action=analysis['decision'],
                    confidence=analysis['confidence'],
                    entry_price=analysis['entry_price'],
                    stop_loss=analysis['stop_loss'],
                    take_profit=analysis['take_profit'],
                    leverage=analysis['leverage'],
                    position_size_pct=analysis['position_size_pct'],
                    strategy=analysis['strategy'],
                    timeframe=analysis['timeframe'],
                    reasoning=analysis['reasoning'],
                    timestamp=datetime.now(),
                    urgency=analysis.get('urgency', 'NORMAL')
                )
                
                self.logger.info(f"ğŸ¯ Signal Generated: {symbol} {signal.action} "
                               f"(Confidence: {signal.confidence:.2f})")
                return signal
            
        except Exception as e:
            self.logger.error(f"âŒ Error generating signal for {symbol}: {e}")
        
        return None
    
    def _construct_advanced_trading_prompt(self, symbol: str, market_data: Dict) -> str:
        """Construct an advanced trading prompt for the AI"""
        
        # Get current position info
        position_info = "No open position"
        if symbol in self.active_positions:
            pos = self.active_positions[symbol]
            position_info = f"Open {pos.side} position: Size={pos.size}, Entry=${pos.entry_price}, PnL=${pos.unrealized_pnl:.2f}"
        
        # Calculate portfolio metrics
        portfolio_risk = self._calculate_portfolio_risk()
        available_capital = self.performance_metrics.current_balance * (1 - portfolio_risk)
        
        # Market condition analysis
        market_condition = self._analyze_market_condition(market_data)
        
        prompt = f"""
        AUTONOMOUS CRYPTO TRADING AGENT - ULTRA HIGH FREQUENCY ANALYSIS
        
        MISSION: Turn ${self.performance_metrics.current_balance:.2f} into $20,000 through aggressive scalping
        
        SYMBOL: {symbol}
        CURRENT PRICE: ${market_data.get('current_price', 0):.6f}
        24H VOLUME: ${market_data.get('volume_24h', 0):,.0f}
        24H CHANGE: {market_data.get('price_change_24h', 0):.2f}%
        
        PORTFOLIO STATUS:
        - Current Balance: ${self.performance_metrics.current_balance:.2f}
        - Available Capital: ${available_capital:.2f}
        - Portfolio Risk: {portfolio_risk:.1%}
        - Today's PnL: ${self.performance_metrics.daily_pnl:.2f}
        - Win Rate: {self.performance_metrics.win_rate:.1%}
        - Total Trades: {self.performance_metrics.total_trades}
        
        CURRENT POSITION: {position_info}
        
        MARKET CONDITION: {market_condition}
        
        TECHNICAL ANALYSIS (Multiple Timeframes):
        {self._format_technical_analysis(market_data)}
        
        ORDER BOOK ANALYSIS:
        {self._format_orderbook_analysis(market_data)}
        
        RECENT TRADE FLOW:
        {self._format_trade_flow_analysis(market_data)}
        
        TRADING RULES:
        1. AGGRESSIVE SCALPING: Target 0.5-2% moves with high leverage
        2. MOMENTUM TRADING: Ride strong trends with trailing stops
        3. RISK MANAGEMENT: Never risk more than 5% per trade
        4. SPEED: Execute within seconds of signal generation
        5. ADAPTATION: Learn from recent trades and market patterns
        
        CURRENT STRATEGY FOCUS:
        - Primary: {self.config['strategy_config']['primary_strategy']}
        - Market Multiplier: {self._get_market_multiplier():.2f}x
        - Volatility Scaling: {self._get_volatility_scaling(symbol):.2f}x
        
        REQUIRED JSON RESPONSE FORMAT:
        {{
            "decision": "BUY|SELL|HOLD|CLOSE",
            "confidence": 0.0-1.0,
            "leverage": 5-50,
            "entry_price": float,
            "stop_loss": float,
            "take_profit": float,
            "position_size_pct": 1-100,
            "strategy": "scalp|momentum|breakout|reversal|squeeze",
            "timeframe": "1m|3m|5m|15m",
            "urgency": "LOW|NORMAL|HIGH|CRITICAL",
            "reasoning": "detailed explanation with specific technical levels"
        }}
        
        EXECUTE ONLY HIGH-PROBABILITY SETUPS WITH CONFIDENCE > 0.75
        PRIORITIZE CAPITAL PRESERVATION WHILE MAXIMIZING GROWTH VELOCITY
        """
        
        return prompt
    
    def _format_technical_analysis(self, market_data: Dict) -> str:
        """Format technical analysis data for the prompt"""
        analysis = []
        
        for tf, df in market_data.get('timeframes', {}).items():
            if df is not None and not df.empty:
                latest = df.iloc[-1]
                analysis.append(f"""
                {tf} Timeframe:
                - Price: ${latest.get('close', 0):.6f}
                - RSI: {latest.get('RSI_14', 0):.1f}
                - MACD: {latest.get('MACD_12_26_9', 0):.6f}
                - BB Position: {self._calculate_bb_position(latest):.2f}
                - Volume Ratio: {self._calculate_volume_ratio(df):.2f}x
                - Trend Strength: {self._calculate_trend_strength(df):.2f}
                """)
        
        return "\n".join(analysis) if analysis else "No technical data available"
    
    def _format_orderbook_analysis(self, market_data: Dict) -> str:
        """Format order book analysis"""
        orderbook = market_data.get('orderbook', {})
        if not orderbook:
            return "No order book data available"
        
        bids = orderbook.get('b', [])[:5]  # Top 5 bids
        asks = orderbook.get('a', [])[:5]  # Top 5 asks
        
        bid_volume = sum(float(bid[1]) for bid in bids)
        ask_volume = sum(float(ask[1]) for ask in asks)
        
        imbalance = (bid_volume - ask_volume) / (bid_volume + ask_volume) if (bid_volume + ask_volume) > 0 else 0
        
        return f"""
        Order Book Imbalance: {imbalance:.3f} (>0.1 = bullish, <-0.1 = bearish)
        Bid Volume: {bid_volume:,.0f}
        Ask Volume: {ask_volume:,.0f}
        Spread: {self._calculate_spread(bids, asks):.6f}
        """
    
    def _format_trade_flow_analysis(self, market_data: Dict) -> str:
        """Format recent trade flow analysis"""
        trades = market_data.get('recent_trades', [])
        if not trades:
            return "No recent trade data available"
        
        # Analyze last 50 trades
        recent_trades = trades[:50]
        buy_volume = sum(float(t['size']) for t in recent_trades if t['side'] == 'Buy')
        sell_volume = sum(float(t['size']) for t in recent_trades if t['side'] == 'Sell')
        
        total_volume = buy_volume + sell_volume
        buy_pressure = buy_volume / total_volume if total_volume > 0 else 0.5
        
        return f"""
        Trade Flow (Last 50 trades):
        - Buy Pressure: {buy_pressure:.1%}
        - Buy Volume: {buy_volume:,.0f}
        - Sell Volume: {sell_volume:,.0f}
        - Momentum: {'BULLISH' if buy_pressure > 0.6 else 'BEARISH' if buy_pressure < 0.4 else 'NEUTRAL'}
        """
    
    async def _execute_trade_signal(self, signal: TradeSignal):
        """Execute a trade signal"""
        try:
            self.logger.info(f"ğŸš€ EXECUTING TRADE: {signal.symbol} {signal.action}")
            
            # Check if we already have a position
            if signal.symbol in self.active_positions:
                if signal.action in ['BUY', 'SELL']:
                    self.logger.info(f"âš ï¸ Already have position in {signal.symbol}, skipping")
                    return
                elif signal.action == 'CLOSE':
                    await self._close_position(signal.symbol)
                    return
            
            # Calculate position size
            position_size = self._calculate_optimal_position_size(signal)
            if not position_size:
                self.logger.warning(f"âš ï¸ Could not calculate position size for {signal.symbol}")
                return
            
            # Place the order
            order_result = await self._place_order(signal, position_size)
            if order_result:
                self.logger.info(f"âœ… Order placed successfully: {signal.symbol}")
                await self._monitor_new_position(signal, order_result)
            else:
                self.logger.error(f"âŒ Failed to place order: {signal.symbol}")
                
        except Exception as e:
            self.logger.error(f"âŒ Error executing trade signal: {e}")
    
    async def _place_order(self, signal: TradeSignal, position_size: float) -> Optional[Dict]:
        """Place an order on ByBit"""
        try:
            # Determine order side
            side = "Buy" if signal.action == "BUY" else "Sell"
            
            # Place market order for immediate execution
            order_params = {
                "category": "linear",
                "symbol": signal.symbol,
                "side": side,
                "orderType": "Market",
                "qty": str(position_size),
                "leverage": str(signal.leverage),
                "stopLoss": str(signal.stop_loss),
                "takeProfit": str(signal.take_profit),
                "timeInForce": "IOC",  # Immediate or Cancel
                "reduceOnly": False
            }
            
            # Set leverage first
            leverage_result = self.bybit_connector.set_leverage(
                category="linear",
                symbol=signal.symbol,
                buyLeverage=str(signal.leverage),
                sellLeverage=str(signal.leverage)
            )
            
            if not leverage_result or leverage_result.get('retCode') != 0:
                self.logger.warning(f"âš ï¸ Could not set leverage for {signal.symbol}")
            
            # Place the order
            result = self.bybit_connector.place_order(**order_params)
            
            if result and result.get('retCode') == 0:
                order_id = result['result']['orderId']
                self.logger.info(f"âœ… Order placed: {order_id}")
                
                # Wait for fill confirmation
                await asyncio.sleep(1)
                order_status = self.bybit_connector.get_order_history(
                    category="linear",
                    symbol=signal.symbol,
                    orderId=order_id
                )
                
                return {
                    'order_id': order_id,
                    'status': order_status,
                    'signal': signal,
                    'position_size': position_size
                }
            else:
                self.logger.error(f"âŒ Order failed: {result}")
                return None
                
        except Exception as e:
            self.logger.error(f"âŒ Error placing order: {e}")
            return None
    
    async def _monitor_new_position(self, signal: TradeSignal, order_result: Dict):
        """Monitor a newly opened position"""
        try:
            # Create position object
            position = Position(
                symbol=signal.symbol,
                side=signal.action,
                size=order_result['position_size'],
                entry_price=signal.entry_price,
                current_price=signal.entry_price,
                unrealized_pnl=0.0,
                leverage=signal.leverage,
                stop_loss=signal.stop_loss,
                take_profit=signal.take_profit,
                timestamp=datetime.now(),
                strategy=signal.strategy
            )
            
            self.active_positions[signal.symbol] = position
            self.performance_metrics.total_trades += 1
            self.performance_metrics.trades_today += 1
            
            self.logger.info(f"ğŸ“Š New position opened: {signal.symbol} {signal.action}")
            
        except Exception as e:
            self.logger.error(f"âŒ Error monitoring new position: {e}")
    
    async def _monitor_positions(self):
        """Monitor all active positions"""
        while self.is_running:
            try:
                if not self.active_positions:
                    await asyncio.sleep(5)
                    continue
                
                # Get current positions from ByBit
                positions_response = self.bybit_connector.get_positions(category="linear")
                
                if positions_response and positions_response.get('retCode') == 0:
                    bybit_positions = {
                        pos['symbol']: pos 
                        for pos in positions_response['result']['list']
                        if float(pos['size']) > 0
                    }
                    
                    # Update our position tracking
                    for symbol, position in list(self.active_positions.items()):
                        if symbol in bybit_positions:
                            bybit_pos = bybit_positions[symbol]
                            position.current_price = float(bybit_pos['markPrice'])
                            position.unrealized_pnl = float(bybit_pos['unrealisedPnl'])
                            
                            # Check for position closure
                            if float(bybit_pos['size']) == 0:
                                await self._handle_position_closure(symbol, position)
                        else:
                            # Position not found on exchange, remove from tracking
                            await self._handle_position_closure(symbol, position)
                
                await asyncio.sleep(self.config['execution_config']['position_check_interval'])
                
            except Exception as e:
                self.logger.error(f"âŒ Error monitoring positions: {e}")
                await asyncio.sleep(5)
    
    async def _handle_position_closure(self, symbol: str, position: Position):
        """Handle when a position is closed"""
        try:
            # Update performance metrics
            if position.unrealized_pnl > 0:
                self.performance_metrics.winning_trades += 1
            else:
                self.performance_metrics.losing_trades += 1
            
            self.performance_metrics.total_pnl += position.unrealized_pnl
            self.performance_metrics.daily_pnl += position.unrealized_pnl
            self.performance_metrics.current_balance += position.unrealized_pnl
            
            # Update peak balance
            if self.performance_metrics.current_balance > self.performance_metrics.peak_balance:
                self.performance_metrics.peak_balance = self.performance_metrics.current_balance
            
            # Calculate win rate
            total_closed = self.performance_metrics.winning_trades + self.performance_metrics.losing_trades
            if total_closed > 0:
                self.performance_metrics.win_rate = (self.performance_metrics.winning_trades / total_closed) * 100
            
            # Remove from active positions
            del self.active_positions[symbol]
            
            self.logger.info(f"ğŸ Position closed: {symbol} PnL: ${position.unrealized_pnl:.2f}")
            self.logger.info(f"ğŸ’° Current Balance: ${self.performance_metrics.current_balance:.2f}")
            
        except Exception as e:
            self.logger.error(f"âŒ Error handling position closure: {e}")
    
    async def _monitor_market_data(self):
        """Monitor market data and update cache"""
        while self.is_running:
            try:
                # Update market data for active symbols
                symbols_to_monitor = set(self.config['trading_symbols'])
                symbols_to_monitor.update(self.active_positions.keys())
                
                for symbol in symbols_to_monitor:
                    # Update ticker data
                    ticker = self.bybit_connector.get_tickers(category="linear", symbol=symbol)
                    if ticker and ticker.get('retCode') == 0:
                        ticker_data = ticker['result']['list'][0]
                        
                        if symbol not in self.market_data_cache:
                            self.market_data_cache[symbol] = {}
                        
                        self.market_data_cache[symbol].update({
                            'current_price': float(ticker_data['lastPrice']),
                            'volume_24h': float(ticker_data['volume24h']),
                            'price_change_24h': float(ticker_data['price24hPcnt']),
                            'last_update': datetime.now()
                        })
                
                await asyncio.sleep(self.config['execution_config']['market_data_refresh_rate'])
                
            except Exception as e:
                self.logger.error(f"âŒ Error monitoring market data: {e}")
                await asyncio.sleep(5)
    
    async def _monitor_performance(self):
        """Monitor and log performance metrics"""
        while self.is_running:
            try:
                # Calculate additional metrics
                self._calculate_advanced_metrics()
                
                # Log performance every 5 minutes
                if self.performance_metrics.total_trades > 0:
                    self.logger.info(f"""
                    ğŸ“Š PERFORMANCE UPDATE ğŸ“Š
                    Balance: ${self.performance_metrics.current_balance:.2f}
                    Daily PnL: ${self.performance_metrics.daily_pnl:.2f}
                    Total Trades: {self.performance_metrics.total_trades}
                    Win Rate: {self.performance_metrics.win_rate:.1f}%
                    Active Positions: {len(self.active_positions)}
                    Max Drawdown: {self.performance_metrics.max_drawdown:.2f}%
                    """)
                
                await asyncio.sleep(self.config['performance_tracking']['performance_log_interval'])
                
            except Exception as e:
                self.logger.error(f"âŒ Error monitoring performance: {e}")
                await asyncio.sleep(60)
    
    async def _monitor_system_health(self):
        """Monitor system health and resources"""
        import psutil
        
        while self.is_running:
            try:
                # Check CPU and memory usage
                cpu_usage = psutil.cpu_percent()
                memory_usage = psutil.virtual_memory().percent
                
                if cpu_usage > self.config['system_config']['max_cpu_usage_pct']:
                    self.logger.warning(f"âš ï¸ High CPU usage: {cpu_usage:.1f}%")
                
                if memory_usage > self.config['system_config']['max_memory_usage_pct']:
                    self.logger.warning(f"âš ï¸ High memory usage: {memory_usage:.1f}%")
                
                # Check for emergency conditions
                if self._check_emergency_conditions():
                    await self.emergency_shutdown()
                    break
                
                await asyncio.sleep(self.config['system_config']['health_check_interval'])
                
            except Exception as e:
                self.logger.error(f"âŒ Error monitoring system health: {e}")
                await asyncio.sleep(60)
    
    def _check_emergency_conditions(self) -> bool:
        """Check for emergency shutdown conditions"""
        # Check maximum drawdown
        if self.performance_metrics.current_balance > 0:
            drawdown = (self.performance_metrics.peak_balance - self.performance_metrics.current_balance) / self.performance_metrics.peak_balance
            if drawdown > self.config['risk_management']['max_drawdown_pct'] / 100:
                self.logger.critical(f"ğŸš¨ EMERGENCY: Max drawdown exceeded: {drawdown:.1%}")
                return True
        
        # Check daily loss limit
        daily_loss_pct = abs(self.performance_metrics.daily_pnl) / self.performance_metrics.current_balance
        if self.performance_metrics.daily_pnl < 0 and daily_loss_pct > self.config['risk_management']['daily_loss_limit_pct'] / 100:
            self.logger.critical(f"ğŸš¨ EMERGENCY: Daily loss limit exceeded: {daily_loss_pct:.1%}")
            return True
        
        return False
    
    async def emergency_shutdown(self):
        """Emergency shutdown procedure"""
        self.logger.critical("ğŸš¨ EMERGENCY SHUTDOWN INITIATED ğŸš¨")
        self.emergency_stop = True
        self.is_running = False
        
        # Close all positions
        for symbol in list(self.active_positions.keys()):
            try:
                await self._close_position(symbol)
            except Exception as e:
                self.logger.error(f"âŒ Error closing position {symbol}: {e}")
        
        # Cancel all pending orders
        await self._cancel_all_orders()
        
        self.logger.critical("ğŸš¨ EMERGENCY SHUTDOWN COMPLETE ğŸš¨")
    
    async def _close_position(self, symbol: str):
        """Close a specific position"""
        try:
            if symbol not in self.active_positions:
                return
            
            position = self.active_positions[symbol]
            
            # Determine close side (opposite of position side)
            close_side = "Sell" if position.side == "BUY" else "Buy"
            
            # Place close order
            result = self.bybit_connector.place_order(
                category="linear",
                symbol=symbol,
                side=close_side,
                orderType="Market",
                qty=str(position.size),
                reduceOnly=True,
                timeInForce="IOC"
            )
            
            if result and result.get('retCode') == 0:
                self.logger.info(f"âœ… Position close order placed: {symbol}")
            else:
                self.logger.error(f"âŒ Failed to close position: {symbol}")
                
        except Exception as e:
            self.logger.error(f"âŒ Error closing position {symbol}: {e}")
    
    async def _cancel_all_orders(self):
        """Cancel all pending orders"""
        try:
            for symbol in self.config['trading_symbols']:
                result = self.bybit_connector.cancel_all_orders(
                    category="linear",
                    symbol=symbol
                )
                if result and result.get('retCode') == 0:
                    self.logger.info(f"âœ… Cancelled all orders for {symbol}")
                    
        except Exception as e:
            self.logger.error(f"âŒ Error cancelling orders: {e}")
    
    # Helper methods for analysis and calculations
    
    def _should_analyze_symbol(self, symbol: str) -> bool:
        """Check if we should analyze a symbol"""
        last_analysis = self.last_analysis_time.get(symbol)
        if not last_analysis:
            return True
        
        time_since_analysis = datetime.now() - last_analysis
        min_interval = timedelta(seconds=self.config['ai_analysis']['analysis_interval_seconds'])
        
        return time_since_analysis >= min_interval
    
    def _validate_ai_response(self, analysis: Dict) -> bool:
        """Validate AI response format"""
        required_fields = [
            'decision', 'confidence', 'entry_price', 'stop_loss', 
            'take_profit', 'leverage', 'position_size_pct', 'strategy', 
            'timeframe', 'reasoning'
        ]
        
        for field in required_fields:
            if field not in analysis:
                return False
        
        # Validate ranges
        if not (0 <= analysis['confidence'] <= 1):
            return False
        
        if not (1 <= analysis['leverage'] <= 100):
            return False
        
        if analysis['decision'] not in ['BUY', 'SELL', 'HOLD', 'CLOSE']:
            return False
        
        return True
    
    def _calculate_optimal_position_size(self, signal: TradeSignal) -> Optional[float]:
        """Calculate optimal position size based on risk management"""
        try:
            available_balance = self.performance_metrics.current_balance
            risk_per_trade = self.config['risk_management']['max_risk_per_trade_pct'] / 100
            
            # Calculate risk amount
            risk_amount = available_balance * risk_per_trade
            
            # Calculate position size based on stop loss distance
            price_diff = abs(signal.entry_price - signal.stop_loss)
            if price_diff <= 0:
                return None
            
            # Base position size
            base_size = risk_amount / price_diff
            
            # Apply leverage
            leveraged_size = base_size * signal.leverage
            
            # Apply position size percentage from signal
            final_size = leveraged_size * (signal.position_size_pct / 100)
            
            # Apply minimum size constraints
            min_size = 0.001  # Minimum position size
            if final_size < min_size:
                return None
            
            return final_size
            
        except Exception as e:
            self.logger.error(f"âŒ Error calculating position size: {e}")
            return None
    
    def _calculate_portfolio_risk(self) -> float:
        """Calculate current portfolio risk"""
        if not self.active_positions:
            return 0.0
        
        total_risk = 0.0
        for position in self.active_positions.values():
            # Calculate risk as potential loss from current price to stop loss
            if position.side == "BUY":
                risk = max(0, position.current_price - position.stop_loss) * position.size
            else:
                risk = max(0, position.stop_loss - position.current_price) * position.size
            
            total_risk += risk
        
        return total_risk / self.performance_metrics.current_balance if self.performance_metrics.current_balance > 0 else 0
    
    def _analyze_market_condition(self, market_data: Dict) -> str:
        """Analyze overall market condition"""
        try:
            price_change = market_data.get('price_change_24h', 0)
            volume_24h = market_data.get('volume_24h', 0)
            
            # Simple market condition classification
            if price_change > 5 and volume_24h > 1000000:
                return "STRONG_BULLISH"
            elif price_change > 2:
                return "BULLISH"
            elif price_change < -5 and volume_24h > 1000000:
                return "STRONG_BEARISH"
            elif price_change < -2:
                return "BEARISH"
            else:
                return "SIDEWAYS"
                
        except Exception:
            return "UNKNOWN"
    
    def _get_market_multiplier(self) -> float:
        """Get market condition multiplier"""
        # This would be more sophisticated in practice
        return 1.0
    
    def _get_volatility_scaling(self, symbol: str) -> float:
        """Get volatility scaling factor"""
        # This would analyze recent volatility
        return 1.0
    
    def _calculate_bb_position(self, data: pd.Series) -> float:
        """Calculate Bollinger Band position"""
        try:
            close = data.get('close', 0)
            bb_upper = data.get('BBU_20_2', close)
            bb_lower = data.get('BBL_20_2', close)
            
            if bb_upper == bb_lower:
                return 0.5
            
            return (close - bb_lower) / (bb_upper - bb_lower)
        except Exception:
            return 0.5
    
    def _calculate_volume_ratio(self, df: pd.DataFrame) -> float:
        """Calculate volume ratio vs average"""
        try:
            if len(df) < 20:
                return 1.0
            
            current_volume = df.iloc[-1]['volume']
            avg_volume = df['volume'].rolling(20).mean().iloc[-1]
            
            return current_volume / avg_volume if avg_volume > 0 else 1.0
        except Exception:
            return 1.0
    
    def _calculate_trend_strength(self, df: pd.DataFrame) -> float:
        """Calculate trend strength"""
        try:
            if len(df) < 20:
                return 0.0
            
            # Simple trend strength based on price vs moving average
            close = df.iloc[-1]['close']
            sma_20 = df['close'].rolling(20).mean().iloc[-1]
            
            return (close - sma_20) / sma_20 if sma_20 > 0 else 0.0
        except Exception:
            return 0.0
    
    def _calculate_spread(self, bids: List, asks: List) -> float:
        """Calculate bid-ask spread"""
        try:
            if not bids or not asks:
                return 0.0
            
            best_bid = float(bids[0][0])
            best_ask = float(asks[0][0])
            
            return best_ask - best_bid
        except Exception:
            return 0.0
    
    def _calculate_advanced_metrics(self):
        """Calculate advanced performance metrics"""
        try:
            # Calculate max drawdown
            if self.performance_metrics.peak_balance > 0:
                current_drawdown = (self.performance_metrics.peak_balance - self.performance_metrics.current_balance) / self.performance_metrics.peak_balance
                self.performance_metrics.max_drawdown = max(self.performance_metrics.max_drawdown, current_drawdown * 100)
            
            # Calculate profit factor
            winning_total = sum(pos.unrealized_pnl for pos in self.active_positions.values() if pos.unrealized_pnl > 0)
            losing_total = abs(sum(pos.unrealized_pnl for pos in self.active_positions.values() if pos.unrealized_pnl < 0))
            
            if losing_total > 0:
                self.performance_metrics.profit_factor = winning_total / losing_total
            
        except Exception as e:
            self.logger.error(f"âŒ Error calculating advanced metrics: {e}")
    
    def _check_daily_limits(self) -> bool:
        """Check if daily trading limits are reached"""
        max_trades = self.config['max_daily_trades']
        max_loss_pct = self.config['risk_management']['daily_loss_limit_pct'] / 100
        
        if self.performance_metrics.trades_today >= max_trades:
            return True
        
        if self.performance_metrics.daily_pnl < 0:
            loss_pct = abs(self.performance_metrics.daily_pnl) / self.performance_metrics.current_balance
            if loss_pct >= max_loss_pct:
                return True
        
        return False
    
    async def celebrate_success(self):
        """Celebrate reaching the target"""
        self.logger.info("ğŸ‰ğŸ‰ğŸ‰ TARGET ACHIEVED! ğŸ‰ğŸ‰ğŸ‰")
        self.logger.info(f"ğŸ’° Final Balance: ${self.performance_metrics.current_balance:.2f}")
        self.logger.info(f"ğŸ“ˆ Total Return: {((self.performance_metrics.current_balance / 2.0) - 1) * 100:.1f}%")
        self.logger.info(f"ğŸ† Total Trades: {self.performance_metrics.total_trades}")
        self.logger.info(f"ğŸ¯ Win Rate: {self.performance_metrics.win_rate:.1f}%")
        
        # Close all positions and stop trading
        await self.emergency_shutdown()


# Main execution function
async def main():
    """Main function to start the autonomous trader"""
    import json
    
    # Load configuration
    config_path = "/Users/skyscope.cloud/Documents/GitHub/Skyscope-AI-ByBit-Trading-Agent/configs/autonomous_trader_config.json"
    
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)
    except FileNotFoundError:
        print(f"âŒ Configuration file not found: {config_path}")
        return
    except json.JSONDecodeError as e:
        print(f"âŒ Invalid JSON in configuration file: {e}")
        return
    
    # Setup logging
    setup_logging(logging.INFO)
    
    # Create and start the autonomous trader
    trader = AutonomousTrader(config)
    
    try:
        await trader.start_trading()
    except KeyboardInterrupt:
        print("\nğŸ›‘ Shutdown requested by user")
        await trader.emergency_shutdown()
    except Exception as e:
        print(f"âŒ Critical error: {e}")
        await trader.emergency_shutdown()


if __name__ == "__main__":
    asyncio.run(main())